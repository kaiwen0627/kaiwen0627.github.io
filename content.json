{"meta":{"title":"kaiwen's blog","subtitle":null,"description":null,"author":"Kaiwen0425","url":"http://yoursite.com"},"pages":[{"title":"404","date":"2018-08-11T02:30:50.000Z","updated":"2018-08-11T02:30:50.958Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-08-11T02:29:39.000Z","updated":"2018-08-11T03:51:55.514Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-11T03:24:15.000Z","updated":"2018-08-11T03:46:43.629Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2018-08-11T03:42:32.000Z","updated":"2018-10-05T12:22:19.628Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"WHO I AMTHIS IS ME!!"}],"posts":[{"title":"javascript算法（壹）","slug":"javascript算法（壹）","date":"2019-07-23T02:07:38.000Z","updated":"2019-07-28T01:35:21.251Z","comments":true,"path":"2019/07/23/javascript算法（壹）/","link":"","permalink":"http://yoursite.com/2019/07/23/javascript算法（壹）/","excerpt":"","text":"JavaScript 语言基础部分1. 数组部分1.1 去重123456789101112131415161718const arr=[1,2,'2',2,3,4,5];// 1. ES6 Setconst set=[...new Set(arr)]console.log(set); // [ 1, 2,'2', 3, 4, 5 ]// 2.for循环function uniq(arr) &#123; let _result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (!_result.includes(arr[i])) &#123; // includes 为 === 比较 _result.push(arr[i]); &#125; &#125; return _result;&#125;console.log(uniq(arr)); // [ 1, 2,'2', 3, 4, 5 ] 1.2 冒泡排序 5个球进行排序，需要比较4轮，共比较次数 4+3+2+1=10次。 比较此时公式： $$\\sum_{i=1} ^{i=n-1} i$$ 12345678910111213141516171819202122232425262728293031323334// 1. bubbleSort不是纯函数，会直接改变引用类型的arrfunction bubbleSort(arr) &#123; for (let i = 0; i &lt; arr.length - 1; i++) &#123; for (let j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; let temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;const arr = [12, 321, 32, 43, 455, 54, 5, 2];bubbleSort(arr);console.log(arr); // [ 2, 5, 12, 32, 43, 54, 321, 455 ]// 2. 纯函数，不会改变原有数组function bubbleSort (arr) &#123; const _arr = [...arr]; // 浅克隆 for (let i = 0; i &lt; _arr.length - 1; i++) &#123; for (let j = 0; j &lt; _arr.length - 1 - i; j++) &#123; if (_arr[j] &gt; _arr[j + 1]) &#123; let temp = _arr[j]; _arr[j] = _arr[j + 1]; _arr[j + 1] = temp; &#125; &#125; &#125; return _arr;&#125;const arr = [12, 321, 32, 43, 455, 54, 5, 2];let result=bubbleSort(arr);console.log(arr); //[ 12, 321, 32, 43, 455, 54, 5, 2 ]console.log(result); // [ 2, 5, 12, 32, 43, 54, 321, 455 ] 1.3 快速排序（二分法排序） 选取一个标杆值。用这个值去和数组中其他的值去依次比较大小。比他的的放在bigger数组，小的放在smaller数组，然后拼接数组。依次递归。 12345678910111213141516171819202122232425function quickSort(arr) &#123; //停止递归 if (arr.length &lt;= 1) &#123; return arr; &#125; //标杆 let p = arr[0]; //存放比标杆大的值 let bigger = []; //存放比标杆小的值 let smaller = []; for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt;= p) &#123; bigger.push(arr[i]); &#125; else &#123; smaller.push(arr[i]); &#125; &#125; //递归调用 return [...quickSort(smaller), p, ...quickSort(bigger)]; // return quickSort(smaller).concat(p,quickSort(bigger))&#125;const arr = [123, 2342, 43, 4354, 54, 656, 76];const result = quickSort(arr);console.log(result); // [ 43, 54, 76, 123, 656, 2342, 4354 ] 1.4 数组扁平化123456789101112131415161718const arr = [0, \"1\", [1, 2], [\"a\", \"b\"], [[[\"xxx\"], 3, 5]]];function flattenArray(arr) &#123; let result = []; //每一项进行遍历，看是不是常数还是数组，如果是数组，则递归调用 for (let i = 0; i &lt; arr.length; i++) &#123; //注意检查数组方法。不能为 typeof if (Array.isArray(arr[i])) &#123; result = [...result, ...flattenArray(arr[i])]; &#125; else &#123; result.push(arr[i]); &#125; &#125; return result;&#125;console.log(flattenArray(arr)); 1.5 拓展功能12345678910//求数组的最大值Math.max.apply(null,arr)// prototypeArray.prototype.max=function ()&#123; return Math.max.apply(null,this)&#125;let a = [1,2,3].max()console.log(a); //3 2.函数2.1 函数科里（curry）化1234567891011121314151617181920function curry(fn) &#123; return function() &#123; //备份实参 let args = arguments; return function() &#123; return fn(...args, ...arguments); &#125;; &#125;;&#125;function fun(a, b, c, d) &#123; return a + b + c + d;&#125;//把fun函数curry化fun = curry(fun);let fn = fun(1, 2);console.log(fun()); // [Function]console.log(fn(3, 4)); // 10 3. 深浅克隆 浅克隆 ： 表层克隆一层，如果数组的某一项是数组，这个内层数组还是内存中的同一个数组。 12345678let arr = [1, 2, 3, [5, 6, 7]];let _arr = [];for (let i = 0; i &lt; arr.length; i++) &#123; _arr.push(arr[i]);&#125;console.log(arr === _arr); // false ，克隆成功console.log(arr[0] === _arr[0]); // true ，第一层，直接复制值console.log(arr[3] === _arr[3]); // true,第二层直接复制指针，不是复制值 深克隆 123456789101112131415161718192021222324252627282930// todo 如何区分正则表达式？let arr = [1, \"2\", 3, [5, 6, 7], null, undefined, /^k[0-9]/g, &#123; name: \"kai\" &#125;];function deepClone(obj) &#123; if (typeof obj !== \"object\") &#123; return obj; &#125; else if (Array.isArray(obj)) &#123; let _arr = []; for (let i = 0; i &lt; obj.length; i++) &#123; if (obj[i] === null) &#123; _arr.push(null); continue; &#125; _arr.push(deepClone(obj[i])); &#125; return _arr; &#125; else if (typeof obj === \"object\") &#123; let _object = &#123;&#125;; for (const key in obj) &#123; _object[key] = obj[key]; &#125; return _object; &#125;&#125;let clone_obj = deepClone(arr);console.log(arr); // [ 1, \"2\", 3, [5, 6, 7], null, undefined, /^k[0-9]/g, &#123; name: \"kai\" &#125;]console.log(clone_obj); // [ 1, '2', 3, [ 5, 6, 7 ], null, undefined, &#123;&#125;, &#123; name: 'kai' &#125; ]console.log(arr === clone_obj); //falseconsole.log(arr[3] === clone_obj[3]); // false 附录1. 使用递归的6种情况： 阶乘 数组扁平化 深克隆 快速排序 杨辉三角、各种三角 脑筋急转弯，eg:不使用for、while循环输出 1-100","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"react之框架（dva&&mirror）","slug":"react之框架（dva&&mirror）","date":"2019-01-13T05:00:38.000Z","updated":"2019-01-13T05:40:55.878Z","comments":true,"path":"2019/01/13/react之框架（dva&&mirror）/","link":"","permalink":"http://yoursite.com/2019/01/13/react之框架（dva&&mirror）/","excerpt":"","text":"上面一章说到了 redux。但是。老实说、配置太麻烦繁琐。所以这段时间研究了下蚂蚁金服的两个 redux 框架，在此总结下做个笔记。 至于 redux 是什么，干什么用就不赘述了。这里只是简单说下使用这两个框架的感受，不强调 API 和代码编写，具体参考官方的文档即可： mirror dva 1.使用体会：1. dva 使用起来更像一个框架，有自己的 模块、路由相关配置，文件结构相对 mirror 严格一些。而 mirror 更像一个库。 这点从使用方法就可以看出来： mirror： 123456789//使用 create-react-app 创建一个新的 app：npm i -g create-react-app$ create-react-app my-app#创建之后，从 npm 安装 Mirror：$ cd my-app$ npm i --save mirrorx$ npm start dva : 123456789101112131415#安装 dva-cli#通过 npm 安装 dva-cli 并确保版本是 0.9.1 或以上#$ npm install dva-cli -g$ dva -vdva-cli version 0.9.1#创建新应用#安装完 dva-cli 之后，就可以在命令行里访问到 dva 命令（不能访问？）。现在，你可以通过 dva new 创建新应用。$ dva new dva-quickstart#这会创建 dva-quickstart 目录，包含项目初始化目录和文件，并提供开发服务器、构建脚本、数据 mock 服务、代理服务器等功能。#然后我们 cd 进入 dva-quickstart 目录，并启动开发服务器：$ cd dva-quickstart$ npm start 初始项目结构： 由于 mirror 是在 create-react-app 脚手架工具上 import 使用，所以他的目录结构比较灵活。 dva 更接近于框架，所以，目录结构和 react-react-app 区别较大。刚上手需要简单熟悉下： — dva 初始项目结构：— mock 存放用于 mock 数据的文件； public 一般用于存放静态文件，打包时会被直接复制到输出目录(./dist)； src 文件夹用于存放项目源代码； asserts 用于存放静态资源，打包时会经过 webpack 处理； components 用于存放 React 组件，一般是该项目公用的无状态组件； models 用于存放模型文件 routes 用于存放需要 connect model 的路由组件；可以在此文件夹中编写“页面” services 用于存放服务文件，一般是网络请求等； utils 工具类库 router.js 路由文件 index.js 项目的入口文件 index.css 一般是共用的样式 .editorconfig 编辑器配置文件 .eslintrc ESLint 配置文件 .gitignore Git 忽略文件 .roadhogrc.mock.js Mock 配置文件 .webpackrc 自定义的 webpack 配置文件，JSON 格式，如果需要 JS 格式，可修改为 - .webpackrc.js 2. 相关知识： 高阶组件： 如果一个函数操作其他函数，即将其他函数作为参数或将函数作为返回值，将其称为高阶函数。高阶组件(high-order component)类似于高阶函数，接收 React 组件作为输入，输出一个新的 React 组件。高阶组件让代码更具有复用性、逻辑性与抽象特征。可以对 render 方法作劫持，也可以控制 props 与 state。 首先，高阶组件不是组件。而是函数！ 简单地说，高阶组件就是一个函数接收参数是一个组件，然后返回一个加工修饰后的组件。典型的高阶组件：redux 中的 connect： 1export default connect(state =&gt; (&#123; state &#125;))(IndexPage); == 传入 IndexPage 组件，给上面绑定 state 数据后返回== (未完待续)","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"},{"name":"react-redux","slug":"react-redux","permalink":"http://yoursite.com/tags/react-redux/"},{"name":"dva","slug":"dva","permalink":"http://yoursite.com/tags/dva/"},{"name":"mirror","slug":"mirror","permalink":"http://yoursite.com/tags/mirror/"}]},{"title":"Redux(二)","slug":"redux(二)","date":"2018-08-29T14:00:38.000Z","updated":"2018-08-29T14:00:56.387Z","comments":true,"path":"2018/08/29/redux(二)/","link":"","permalink":"http://yoursite.com/2018/08/29/redux(二)/","excerpt":"","text":"上面一章说到了redux。这一节总结一下redux在react中的使用。即：react——redux React-reduxRedux 官方提供的 React 绑定库。 具有高效且灵活的特性。 通俗理解： 请参考 redux和react-redux小记 非常浅显明白，给赞！！！ 1.安装 1npm install --save react-redux 2.使用疑问","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"},{"name":"react-redux","slug":"react-redux","permalink":"http://yoursite.com/tags/react-redux/"}]},{"title":"Redux(一)","slug":"redux(一)","date":"2018-08-22T14:00:38.000Z","updated":"2018-08-22T15:01:38.010Z","comments":true,"path":"2018/08/22/redux(一)/","link":"","permalink":"http://yoursite.com/2018/08/22/redux(一)/","excerpt":"","text":"如果要用一句话来概括Redux，那么可以使用官网的这句话：Redux是针对JavaScript应用的可预测状态容器。此句话虽然简单，但包含了以下几个含义： 可预测性(predictable): 因为Redux用了reducer与纯函数(pure function)的概念，每个新的state都会由旧的state建来一个全新的state。因而所有的状态修改都是”可预测的”。 状态容器(state container): state是集中在单一个对象树状结构下的单一store，store即是应用程序领域(app domain)的状态集合。 JavaScript应用: 这说明Redux并不是单指设计给React用的，它是独立的一个函数库，可通用于各种JavaScript应用。 Redux基于简化版本的Flux框架，Flux是Facebook开发的一个框架。在标准的MVC框架中，数据可以在UI组件和存储之间双向流动，而Redux严格限制了 数据只能在一个方向上流动。 为了说明整个模型的运作流程，首先我们需要弄清Redux模型中的几个组成对象：action 、reducer、store。 action：官方的解释是action是把数据从应用传到 store 的有效载荷，它是 store 数据的唯一来源；要通过本地或远程组件更改状态，需要分发一个action； reducer：action发出了做某件事的请求，只是描述了要做某件事，并没有去改变state来更新界面，reducer就是根据action的type来处理不同的事件； store：store就是把action和reducer联系到一起的对象，store本质上是一个状态树，保存了所有对象的状态。任何UI组件都可以直接从store访问特定对象的状态。 在Redux中，所有的数据（比如state）被保存在一个被称为store的容器中 ，在一个应用程序中只能有一个store对象。当一个store接收到一个action，它将把这个action代理给相关的reducer。reducer是一个纯函数，它可以查看之前的状态，执行一个action并且返回一个新的状态。 Redux配置配置Redux开发环境的最快方法是使用create-react-app工具。在开始之前，确保已经安装并更新了nodejs、npm和yarn。下面以生成一个redux-shopping项目并安装Redux为例。 如果没有安装create-react-app工具，请使用下面的命令先执行安装操作。 1npm install -g create-react-app 然后，在使用下面的命令创建redux-shopping项目。 123create-react-app redux-shoppingcd redux-shoppingyarn add redux 首先，删除src文件夹中除index.js以外的所有文件。打开index.js，删除所有代码，键入以下内容： 1234567import &#123; createStore &#125; from \"redux\";const reducer = function(state, action) &#123; return state;&#125;const store = createStore(reducer); 上面代码的意思是： 从redux包中引入createStore()方法； 创建了一个名为reducer的方法，第一个参数state是当前保存在store中的数据，第二个参数action是一个容器，用于： type - 一个简单的字符串常量，例如ADD, UPDATE, DELETE等。 payload - 用于更新状态的数据。 创建一个Redux存储区，它只能使用reducer作为参数来构造。存储在Redux存储区中的数据可以被直接访问，但只能通过提供的reducer进行更新。 目前，state为undefined或null，要解决这个问题，需要分配一个默认的值给state，使其成为一个空数组。例如： 123const reducer = function(state=[], action) &#123; return state;&#125; 目前我们创建的reducer是通用的，那么我们如何使用多个reducer呢？此时我们可以使用Redux包中提供的combineReducers函数。做如下内容修改： 123456789101112131415161718192021// src/index.jsimport &#123; createStore &#125; from \"redux\";import &#123; combineReducers &#125; from 'redux';const productsReducer = function(state=[], action) &#123; return state;&#125;const cartReducer = function(state=[], action) &#123; return state;&#125;const allReducers = &#123; products: productsReducer, shoppingCart: cartReducer&#125;const rootReducer = combineReducers(allReducers);let store = createStore(rootReducer); 接下来，我们将为reducer定义一些测试数据。 12345678910111213141516171819202122232425262728// src/index.js…const initialState = &#123; cart: [ &#123; product: 'bread 700g', quantity: 2, unitCost: 90 &#125;, &#123; product: 'milk 500ml', quantity: 1, unitCost: 47 &#125; ]&#125;const cartReducer = function(state=initialState, action) &#123; return state;&#125;…let store = createStore(rootReducer);console.log(\"initial state: \", store.getState()); 接下来，我们可以在终端中执行npm start或者yarn start来运行dev服务器，并在控制台中查看state。 现在，我们的cartReducer什么也没做，但它应该在Redux的存储区中管理购物车商品的状态。我们需要定义添加、更新和删除商品的操作(action)。此时我们可以做如下的一些定义： 123456789101112131415161718192021// src/index.js…const ADD_TO_CART = 'ADD_TO_CART';const cartReducer = function(state=initialState, action) &#123; switch (action.type) &#123; case ADD_TO_CART: &#123; return &#123; ...state, cart: [...state.cart, action.payload] &#125; &#125; default: return state; &#125;&#125;… 我们继续来分析一下代码。一个reducer需要处理不同的action类型，因此我们需要一个SWITCH语句。当一个ADD_TO_CART类型的action在应用程序中分发时，switch中的代码将处理它。 接下来，我们将定义一个action，作为store.dispatch()的一个参数。action是一个Javascript对象，有一个必须的type和可选的payload。我们在cartReducer函数后定义一个： 12345678…function addToCart(product, quantity, unitCost) &#123; return &#123; type: ADD_TO_CART, payload: &#123; product, quantity, unitCost &#125; &#125;&#125;… 在这里，我们定义了一个函数，返回一个JavaScript对象。在我们分发消息之前，我们添加一些代码，让我们能够监听store事件的更改。 123456…let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); 接下来，我们通过分发消息到store来向购物车中添加商品。将下面的代码添加在unsubscribe()之前： 123store.dispatch(addToCart('Coffee 500gm', 1, 250));store.dispatch(addToCart('Flour 1kg', 2, 110));store.dispatch(addToCart('Juice 2L', 1, 250)); 到此，我们已经走通了redux的简易流程。不过代码有点乱。维护成本太高。所以我们需要拆分代码。 代码拆分会发现，index.js中的代码逐渐变得冗杂。所以，接下来我们对上面的项目进行一个组织拆分，使之成为Redux项目。首先，在src文件夹中创建一下文件和文件夹，文件结构如下： 123456789src/├── actions│ └── cart-actions.js├── index.js├── reducers│ ├── cart-reducer.js│ ├── index.js│ └── products-reducer.js└── store.js 然后，我们把index.js中的代码进行整理： 12345678910// src/actions/cart-actions.jsexport const ADD_TO_CART = 'ADD_TO_CART';export function addToCart(product, quantity, unitCost) &#123; return &#123; type: ADD_TO_CART, payload: &#123; product, quantity, unitCost &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132// src/reducers/cart-reducer.jsimport &#123; ADD_TO_CART &#125; from '../actions/cart-actions';const initialState = &#123; cart: [ &#123; product: 'bread 700g', quantity: 2, unitCost: 90 &#125;, &#123; product: 'milk 500ml', quantity: 1, unitCost: 47 &#125; ]&#125;export default function(state=initialState, action) &#123; switch (action.type) &#123; case ADD_TO_CART: &#123; return &#123; ...state, cart: [...state.cart, action.payload] &#125; &#125; default: return state; &#125;&#125; 1234567891011121314// src/reducers/index.jsimport &#123; combineReducers &#125; from 'redux';import productsReducer from './products-reducer';import cartReducer from './cart-reducer';const allReducers = &#123; products: productsReducer, shoppingCart: cartReducer&#125;const rootReducer = combineReducers(allReducers);export default rootReducer; 12345678// src/store.jsimport &#123; createStore &#125; from \"redux\";import rootReducer from './reducers';let store = createStore(rootReducer);export default store; 12345678910111213141516// src/index.jsimport store from './store.js';import &#123; addToCart &#125; from './actions/cart-actions';console.log(\"initial state: \", store.getState());let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));store.dispatch(addToCart('Coffee 500gm', 1, 250));store.dispatch(addToCart('Flour 1kg', 2, 110));store.dispatch(addToCart('Juice 2L', 1, 250));unsubscribe(); 整理完代码之后，程序依然会正常运行.现在我们来添加修改和删除购物车中商品的逻辑。修改cart-actions.js和cart-reducer.js文件： 123456789101112131415161718192021222324// src/reducers/cart-actions.js…export const UPDATE_CART = 'UPDATE_CART';export const DELETE_FROM_CART = 'DELETE_FROM_CART';…export function updateCart(product, quantity, unitCost) &#123; return &#123; type: UPDATE_CART, payload: &#123; product, quantity, unitCost &#125; &#125;&#125;export function deleteFromCart(product) &#123; return &#123; type: DELETE_FROM_CART, payload: &#123; product &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829// src/reducers/cart-reducer.js…export default function(state=initialState, action) &#123; switch (action.type) &#123; case ADD_TO_CART: &#123; return &#123; ...state, cart: [...state.cart, action.payload] &#125; &#125; case UPDATE_CART: &#123; return &#123; ...state, cart: state.cart.map(item =&gt; item.product === action.payload.product ? action.payload : item) &#125; &#125; case DELETE_FROM_CART: &#123; return &#123; ...state, cart: state.cart.filter(item =&gt; item.product !== action.payload.product) &#125; &#125; default: return state; &#125;&#125; 最后，我们在index.js中分发这两个action： 12345// Update Cartstore.dispatch(updateCart('Flour 1kg', 5, 110));// Delete from Cartstore.dispatch(deleteFromCart('Coffee 500gm')); 使用Redux工具进行调试Redux拥有很多第三方的调试工具，可用于分析代码和修复bug。最受欢迎的是time-travelling tool，即redux-devtools-extension。设置它只需要三个步骤。 首先，在Chrome中安装Redux Devtools扩展；然后，在运行Redux应用程序的终端里使用Ctrl+C停止服务器。并用npm或yarn安装redux-devtools-extension包； 1yarn add redux-devtools-extension 一旦安装完成，我们对store.js稍作修改都会反映到结果上。例如，我们还可以把src/index.js中日志相关的代码删除掉。返回Chrome，右键单击该工具的图标，打开Redux DevTools面板。","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"vi 操作指南","slug":"vi操作指南","date":"2018-08-21T13:00:38.000Z","updated":"2018-08-21T13:21:16.678Z","comments":true,"path":"2018/08/21/vi操作指南/","link":"","permalink":"http://yoursite.com/2018/08/21/vi操作指南/","excerpt":"","text":"最近工作中总是与linux、git打交道，不可避免的要使用vim文本编辑器。在此，将一些常见的操作整理出来。做个总结。同时，通过网上查找再加强学习。 什么是vi？ vi(vim)可以说是linux中用得最多的工具了，不管你配置服务也好，写脚本也好，总会用到它。但是，vim作为一个“纯字符”模式下的工具，它的操作和WINDOWS中的文本编辑工具相比多少有些复杂。 基本概念基本上vi可分为三种操作状态，分别是命令模式（Command mode）、插入模式（Insert mode）和底线命令模式（Last line mode），各模式的功能区分如下： Comand mode：控制屏幕光标的移动，字符或光标的删除，移动复制某区段及进入Insert mode下，或者到Last line mode。 Insert mode：唯有在Insert mode下，才可做文字数据输入，按Esc等可回到Comand mode。 Last line mode：将储存文件或离开编辑器，也可设置编辑环境，如寻找字符串、列出行号等。 不过可以把vi简化成两个模式，即是将Last line mode也算入Command mode,把vi分成Command 和Insert mode。 基本操作 进入vi编辑模式： 1vi text.sh #在系统提示符号输入vi及文件名称后，即可进入vi全屏幕编辑画面 编辑文件 进入vi之后是处于“Command mode”下，您要切换到Insert mode才能输入文字。 在Command mode下按‘i’、‘a’或‘o’三键就可进入Insert mode。这时候您就可以开始输入文字了。 i : 插入，从目前光标所在之处插入所输入的文字。 a : 增加，目前光标所在的下一个字开始输入文字。 o : 插入新的一行，从行首开始输入文字。 Insert的切换→Command mode，按Esc键(退出编辑状态)： 您目前处于Insert mode，您就只能一直打字。假如您发现打错字了，想用光标键往回移动，将该字删除，就要按ESC键转换回Command mode，再删除文字。 多行注释/反注释 1.多行注释： Ctrl+v 进入块级编辑模式 操作光标上下 选取被注释区域 输入I {大写的i} 进入多行插入修改模式 输入# 输入要插入的字符 按ESC 退出多行插入模式 2.取消注释 Ctrl+v 进入块级编辑模式 操作光标上下 选取被注释区域 按d删除第一列#号 按ESC 退出多行插入模式 离开vi及存文件在Command mode下，可按冒号“：”键入入Last line mode，例如： :w filename (输入“w filename”，将文章存入指定的文件名filename) :wq (输入“wq”，因为进入之时已经指定文件名testfile，所以会写入testfile并离开vi) :q! (输入“q!”，强制离开并放弃编辑的文件) Command mode功能键列表 移动光标 第一种方法：上下左右按键【好像白说了~~】 第二种方法：vi标准按键： h、j、k、l，分别控制光标左、下、上、右移一格。 翻页 按Ctrl+B：屏幕往后移动一页。[常用] 按Ctrl+F：屏幕往前移动一页。[常用] 按Ctrl+U：屏幕往后移动半页。 按Ctrl+D：屏幕往前移动半页。 按 0 （数字零）：移动文章的开头。[常用] 按 G：移动到文章的最后。[常用] 按 w：光标跳到下个word的开头。[常用] 按 e：光标跳到下个word的字尾。 按 b：光标回到上个word的开头。 按 $：移到光标所在行的行尾。[常用] 按 ^：移到该行第一个非空白的字符。 按 0：移到该行的开头位置。[常用] 按 #：移到该行的第#个位置，例：51、121。[常用] 删除文字 x：每按一次删除光标所在位置的后面一个字符。[超常用] dd：删除光标所在行。[超常用] yy：复制光标所在行。[超常用] p：复制单行到您想粘贴之处。（指令‘yy’与‘p’必须搭配使用） 撤销操作 u：假如您误操作一个指令，可以马上按u，回复到上一个操作。[超常用] 跳至指定行 Ctrl+G：列出光标所在行的行号。例如，15G，表示移动光标至文章的第15行行首。[常用] Last line mode下指令简介先按Esc键确定您已经处于Command mode下后，再按冒号“：”或“/”或“？”三键的其中一键进入Last line mode。 列出行号 set nu: 输入“set nu”后，会在文章的每一行前面列出行号。 跳到文章的某一行 #：井号代表一个数字，在Last line mode提示符号“：”前输入数字，再按Enter就会跳到该行了，如：15[Enter]就会跳到文章的第15行。[常用] 寻找字符串 /关键字：先按/，再输入您想寻找的字，如果第一次找的关键字不是您相尽可能的，可以一直按n会往下寻找到您要的关键字为止。 ？关键字：先按？，再输入您想寻找的字，如果第一次找的关键字不是您想要的，可以按n会往前寻找到您要的关键字为止。 取代字符串 1，$s/string/replae/g：在last line mode输入“ 1,$s/string/replace/g ”会将全文的string字符串取代为replace字符串，其中1,$s就是指搜寻区间为文章从头至尾的意思，g则是表示全部取代不必确认。 %s/string/replace/c：同样会将全文的string字符串取代为replace字符串，和上面指令不同的地方是，%s和1,$s是相同的功能，c则是表示要替代之前必须再次确认是否取代。 1,20s/string/replace/g：将1至20行间的string替代为relpace字符串。 存文件 w：在last line mode提示符号“：”前按w即可将文件存起来。[超常用] 离开 q：按q就离开，有时如果无法离开vi，可搭配“！：强置离开vi，如“q！” qw：一般建议离开时，搭配w一起使用，如此离开时还可存文件。[常用]","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"git操作指南（1）","slug":"git操作指南","date":"2018-08-20T01:00:38.000Z","updated":"2019-07-28T01:26:22.671Z","comments":true,"path":"2018/08/20/git操作指南/","link":"","permalink":"http://yoursite.com/2018/08/20/git操作指南/","excerpt":"","text":"小公司一般都会使用 svn 托管代码。工作原因，需要使用 git。没办法，硬着头皮上。第一次在超大的代码库中用 git 提交进去自己的两行字符串，还是挺兴奋的呢。【滑稽.jpg】 安装配置 安装： 这个好像没什么说的，百度 git–&gt;傻瓜下一步安装【手动狗头.jpg】 配置： 12$ git config --global user.name \"John Doe\"$ git config --global user.email johndoe@example.com 关联 github 生成密钥对 大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看： 123$ cd ~/.ssh$ lsauthorized_keys2 id_dsa known_hosts config id_dsa.pub 假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里： 12345$ ssh-keygen -t rsa -C \"your_email@youremail.com\"Creates a new ssh key using the provided email # Generating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa): 直接按 Enter 就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)： 1Enter same passphrase again: [Type passphrase again] 完了之后，大概是这样： 12Your public key has been saved in /home/you/.ssh/id_rsa.pub.The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com 2.添加公钥到你的远程仓库（github） 2.1、查看你生成的公钥： 123$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ/v7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8vR3c8E7CjZN733f5AL8uEYJA+YZevY5UCvEg+umT7PHghKYaJwaCxV7sjYP7Z6V79OMCEAGDNXC26IBMdMgOluQjp6o6j2KAdtRBdCDS/QIU5THQDxJ9lBXjk1fiq9tITo/aXBvjZeD+gH/Apkh/0GbO8VQLiYYmNfqqAHHeXdltORn8N7C9lOa/UW3KM7QdXo6J0GFlBVQeTE/IGqhMS5PMln3 admin@admin-PC 2.2、登陆你的github帐户。点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key 2.3、然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。 2.4、点击 Add key。 完成以后，验证下这个key是不是正常工作： 12345$ ssh -T git@github.comAttempts to ssh to githubHi xxx! You've successfully authenticated, but GitHub does not # provide shell access. git 常用命令 拉取代码 123git clone git@githome**** #从远程仓库克隆代码【master分支】git clone -b xxx git@githome**** #从远程仓库克隆代码【xxx分支】 修改代码 进入代码文件夹后开发代码 检查工作区状态 1git status 检查分支 12git branch #查看目前所在分支git checkout dev #切换到dev分支 增加改动到缓存区 1git add * #增加所有改动到缓存区 提交代码到本地仓库 1git commit -m \"提交描述信息\" 推送到远程服务器 12git push #推送代码到master分支git push origin -u xxx #推送代码到xxx分支","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"LINUX 初体验(二)","slug":"LINUX-初体验（二）","date":"2018-08-19T04:00:38.000Z","updated":"2018-08-19T05:19:43.716Z","comments":true,"path":"2018/08/19/LINUX-初体验（二）/","link":"","permalink":"http://yoursite.com/2018/08/19/LINUX-初体验（二）/","excerpt":"","text":"本文主要是对linux下的shell编程相关知识做一下总结。 1.什么是SHELL？什么是SHELL脚本？ Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 Shell 脚本（shell script），是一种为 shell 编写的脚本程序。业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。由于习惯的原因，简洁起见，本文出现的 “shell编程” 都是指 shell 脚本编程，不是指开发 shell 自身。 简单来说，shell和shell脚本就是雷锋与雷峰塔的区别，听着都与雷锋有关而已。 2.shell脚本 shell脚本就是将一些linux操作命令集成为“.sh”脚本 shell脚本第一行一般如下： 1#!/bin/bash shell脚本运行的方法： 1.作为解释器参数 1bash ./text.sh 2.作为可执行程序 1./text.sh 注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 3.shell编程注意事项：1. 变量&amp;&amp;字符串 字符串变量定义时，单引号里面不能有其他变量拼接，会原样输出；在双引号里面可以包含其他变量引用后输出。 定义变量时，变量名不加美元符号$,使用变量需要在前边加 $num 或者写成 ${num} 。 变量重新赋值不属于使用变量，不需要加$ 。 12345your_name=\"kw\" #定义变量echo $your_name #使用变量your_name=\"tiantian\" #重新赋值echo your name is $your_name ! #使用变量echo your name is $&#123;your_name&#125; ! #使用变量 字符串拼接直接将变量“放置”在对于位置即可。 变量相关其他知识可以参考 菜鸟教程 相关章节。 2.参数传递shell执行机制本身就比较”傻”，它会从上到下一条条命令执行。假如没有做容错处理，执行错误了，也不会停止，会继续执行下面的命令直到脚本底部 假如测试脚本 file.sh 如下： 123456#!/bin/bashecho \"Shell 传递参数实例！\";echo \"执行的文件名：$0\";echo \"第一个参数为：$1\";echo \"第二个参数为：$2\";echo \"第三个参数为：$3\"; 我们调用执行他： 12chmod +x file.sh #给文件file.sh添加自执行权限./file.sh 1 2 3 #调用脚本并传入参数 执行结果： 12345Shell 传递参数实例！执行的文件名：./file.sh第一个参数为：1第二个参数为：2第三个参数为：3 shell的脚本调用传参必须严格遵守传参顺序 4.shell数组1.定义方法： 1arr=(A B \"C\" D) 2.注意点： 数组定义以 () 包裹。 shell数组只支持一维数组。 shell数组元素以空格分割 数组元素获取方法和JScript相同。 123arr1=arr[0] #获取数组第一个元素arrL=arr[@] #获取数组长度arrL=arr[*] #同上 5.流程控制shell里面的流程控制语句，一定要注意关键词的之后空格和缩进 if 1234567if conditionthen command1 command2 ... commandN fi if-else 12345678num1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo '两个数字相等!'else echo '两个数字不相等!'fi for 1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 6.函数shell里面的函数定义与JScript一样,不过要注意缩进，调用时如果不需要传参，不跟() 12345678910111213#!/bin/bashfunWithReturn()&#123; echo \"这个函数会对输入的两个数字进行相加运算...\" echo \"输入第一个数字: \" read aNum echo \"输入第二个数字: \" read anotherNum echo \"两个数字分别为 $aNum 和 $anotherNum !\" return $(($aNum+$anotherNum))&#125;funWithReturn #函数调用echo \"输入的两个数字之和为 $? !\" 函数传参方法： 类似脚本运行传参,参数获取从$1开始，代表第一个参数。 123456789101112funWithReturn()&#123; echo \"第一个参数为：$1\"; echo \"第二个参数为：$2\"; echo \"第三个参数为：$3\";&#125;funWithReturn a b c #函数传参调用================================第一个参数为：a第一个参数为：b第一个参数为：c 7.Shell 输入/输出重定向 大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 用的较多的几个： 123command 1 &gt; file1.log #将运行结果输入到file1.log文件中。command 2 &gt;&gt; file #将运行结果输入追加到file1.log文件中。不删除以前的。command &gt; /dev/null #/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到\"禁止输出\"的效果。 8.Shell 文件包含 和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。 123. filename # 注意点号(.)和文件名中间有一空格.可以理解为JScript里面的import后可以直接使用filename中的变量、方法等. 【未完待续】","categories":[{"name":"linux&&shell","slug":"linux-shell","permalink":"http://yoursite.com/categories/linux-shell/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"后台","slug":"后台","permalink":"http://yoursite.com/tags/后台/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"css技巧(一)","slug":"css技巧","date":"2018-08-11T16:00:38.000Z","updated":"2019-07-28T01:37:54.842Z","comments":true,"path":"2018/08/12/css技巧/","link":"","permalink":"http://yoursite.com/2018/08/12/css技巧/","excerpt":"","text":"此文引用自：火头军人 ,仅为学习目的。 在页面构建中，能明显提升页面显示质量的一些 CSS 小技巧。很多简洁美观的页面表现，可以使用 CSS3 代码即可实现，减少图片的使用。 一、边框内圆角我们在设计例如按钮等控件的时候，会遇到这样的设计：只有内侧有圆角，而边框或者描边的四个角还是保持直角的形状，用以下代码可以轻松的实现。 1234567891011121314151617#wrapper &#123; width: 200px; height: 80px; padding: 10px; background: rgb(255, 187, 51); #content &#123; display: flex; justify-content: center; align-items: center; height: 100%; background: rgb(85, 136, 187); color: #fff; font-size: 14px; border-radius: 20px; &#125;&#125; 这种解决方案需要使用到两个 dom 元素，那么如果只使用一个 dom 元素，应该怎么实现？ 这里需要用到 CSS 的两个属性： box-shadow 和 outline 属性，具体属性参见 MDN。 box-shadow 属性有以下 5 个特性 inset offset-x offset-y blur-radius spread-radius color 这里我们将使用第四个属性 spread-radius 来填充效果当中的空白。同时利用 outline 的特性：描边不跟随边框绘制的特点来实现（因为不清楚这是不是一个 bug，所以在将来的版本中可能会改变），具体代码如下。 12box-shadow: 0 0 0 10px rgb(255, 187, 51);outline: 10px solid rgb(255, 187, 51); 这种实现方式，对于边框的宽度和圆角的大小有一定的限制效果。仅当边框宽度 w 与圆角半径 r 存在 w ≥ (√2-1)r 关系时才可实现. 二、条纹背景如何使用 CSS 来实现条纹？ 使用 linear-gradient 属性实现 12345#stripe &#123; width: 400px; height: 200px; background: linear-gradient(rgb(255, 187, 51), rgb(85, 136, 187));&#125; 尝试修改 linear-gradient 属性，当 linear-gradient 属性 1background: linear-gradient(rgb(255, 187, 51) 50%, rgb(85, 136, 187) 50%); 因为条纹是由 background-image 属性生成的，因此当然也可以使用 background-size 属性来改变它的大小 1background-size: 100% 40px; 如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值。 1background: linear-gradient(rgb(255, 187, 51) 60%, rgb(85, 136, 187) 0); 123456background: linear-gradient( rgb(255, 187, 51) 33.3%, rgb(85, 136, 187) 0, rgb(85, 136, 187) 66.6%, rgb(170, 255, 0) 0); 垂直条纹1background: linear-gradient(to right, rgb(255, 187, 51) 60%, rgb(85, 136, 187) 0); 默认值为 to bottom ，可以设置 to right; to left 等 斜条纹 12345678910background: linear-gradient( 45deg, rgb(255, 187, 51) 25%, rgb(85, 136, 187) 0, rgb(85, 136, 187) 50%, rgb(255, 187, 51) 0%, rgb(255, 187, 51) 75%, rgb(85, 136, 187) 0);background-size: 30px 30px; 为了达到斜条纹等宽的视觉效果，需要运用到勾股定理来计算宽度。 1background-size: 42px 42px; 介绍 linear-gradient 的升级版 ： repeating-linear-gradient 可以试着使用 linear-gradient 和 repeating-linear-gradient 实现同样的 60° 斜条纹进行对比 1234567891011121314151617181920background: linear-gradient( 60deg, rgb(255, 187, 51), rgb(255, 187, 51) 25%, rgb(85, 136, 187) 0, rgb(85, 136, 187) 50%, rgb(255, 187, 51) 0, rgb(255, 187, 51) 75%, rgb(85, 136, 187) 0, rgb(85, 136, 187) 100%);background-size: 18px 31px;background: repeating-linear-gradient( 60deg, rgb(255, 187, 51), rgb(255, 187, 51) 15px, rgb(85, 136, 187) 0, rgb(85, 136, 187) 30px); 三、平行四边形和梯形使用 transform 属性可以很轻松的创建一个平行四边形 1234567891011121314#content &#123; display: flex; justify-content: center; align-items: center; width: 200px; height: 80px; background: rgb(85, 136, 187); color: #fff; font-size: 14px; transform: skewX(-30deg); span &#123; transform: skewX(30deg); &#125;&#125; 缺点：需要两个元素、修改的话需要修改两个地方。 如何使用一个元素就实现这样的效果。 解决办法：将平行四边形的背景设置在伪元素上，对伪元素进行变形。 12345678910111213141516171819202122#content &#123; position: relative; display: flex; justify-content: center; align-items: center; width: 120px; height: 60px; font-size: 18px; font-weight: 600; color: #fff; &amp;::after &#123; content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; transform: skewX(-30deg); background: rgb(85, 136, 187); z-index: -1; &#125;&#125; 梯形的概念比平行四边形更加宽泛，只需要两条边平行即可。梯形常用于标签页，之前常用伪元素方法来实现一个梯形。 12345678910111213141516171819202122232425262728293031323334353637.trapezoid &#123; position: relative; left: 200px; width: 400px; height: 180px; background: rgb(85, 136, 170); display: flex; justify-content: center; align-items: center; font-size: 48px; color: rgb(255, 255, 255); &amp;::before, &amp;::after &#123; content: ''; position: absolute; &#125; &amp;::before &#123; position: absolute; top: 0; left: -100px; width: 0; height: 0; border-top: 180px solid transparent; border-bottom: 0 solid transparent; border-right: 100px solid rgb(255, 187, 51); &#125; &amp;::after &#123; position: absolute; top: 0; right: -240px; width: 0; height: 0; border-top: 180px solid transparent; border-bottom: 0 solid transparent; border-left: 240px solid rgb(255, 187, 51); &#125;&#125; 缺点： 把两个伪元素都使用了； 需要修改形状时，需要修改的方过多； 不能给梯形加边框、阴影； 不能设置成圆角梯形； 通过构造平行四边形的思想，对矩形进行变形。但是这次不采用 2d 平面的变形，而是 3d 平面变形，通过视觉差来构造一个梯形。 这里需要用到 transform 属性 3d 变换特性： perspective rotate3d (rotateX rotateY rotateZ) transform-origin scale3d (scaleX scaleY scaleZ)实现一个最简单的梯形所需要的代码只有以下一行： 1transform: perspective(200px) rotateX(30deg); 与 2d 变换不同，3d 内部变形是不可逆的，因此与构造平行四边形相似，我们也可以将图形的变形放在伪元素上。 12345678910111213141516171819202122.trapezoid &#123; position: relative; left: 200px; width: 400px; height: 180px; display: flex; justify-content: center; align-items: center; font-size: 48px; color: rgb(255, 255, 255); &amp;::before &#123; content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgb(85, 136, 170); transform: perspective(200px) rotateX(30deg); z-index: -1; &#125;&#125; 优化 1、修改 transform-origin 属性，控制转动轴 1transform-origin: bottom; 2、通过 scale3d 属性而非 padding 属性来修正视觉大小，同时兼顾了优雅降级 1transform: perspective(200px) rotateX(30deg) scaleY(2.25); 3、添加圆角、阴影、背景渐变 1234background: linear-gradient(to right, rgb(85, 136, 170), rgb(255, 187, 51));border-top-right-radius: 60px;border-top-left-radius: 60px;box-shadow: 10px 10px 10px 1px rgba(85, 136, 170, 0.2); 4、改变 transform-origin 得到不同斜边的梯形 12transform: perspective(200px) rotateX(10deg);transform-origin: left; 缺点 斜边的角度依赖于元素的宽度。因此，当元素的内容长度不等时，想要得到斜度一致的梯形就不容易了。 3d 变换具体实现原理参见 matrix3d 四、阴影投影首先会想到 box-shadow 这个属性，根据以上的介绍，我们可以轻松的做出一个元素的阴影 123456#shadow &#123; width: 200px; height: 100px; background: rgb(255, 187, 51); box-shadow: 240px 120px 0 0 red;&#125; 那么如何针对一张图片实现其对应的阴影？在页面的例如头像显示会遇到这种效果 这里将会使用到 CSS3 里面的 filter 属性 1234567891011121314151617#logo &#123; position: relative; width: 200px; height: 200px; background: url('../img/logo.svg') no-repeat; &amp;::after &#123; content: ''; position: absolute; top: 40px; left: 0; width: 100%; height: 100%; background: url('../img/logo.svg') no-repeat; background-size: 100% 100%; filter: blur(10px); &#125;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"LINUX 初体验","slug":"LINUX-初体验","date":"2018-08-06T16:00:38.000Z","updated":"2018-08-12T12:20:00.586Z","comments":true,"path":"2018/08/07/LINUX-初体验/","link":"","permalink":"http://yoursite.com/2018/08/07/LINUX-初体验/","excerpt":"","text":"工作原因，需要学习并使用linux以及shell后台相关操作。借此，总结一下遇到的常见操作。一来是方便自己查询，而来也是对自己学习做个总结。 1.基础知识 1.1 在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。 1.2 文件系统的最顶层是由根目录开始的，系统使用 / 来表示根目录。在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含子目录文件。如此反复就可以构成一个庞大的文件系统。 1.3 在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 . 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点 .. 来表示。 . ：代表当前的目录，也可以使用 ./ 来表示； .. ：代表上一层目录，也可以 ../ 来代表。 如果一个目录或文件名以一个点 . 开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)。即以默认方式查找时，不显示该目录或文件。 2.文件相关操作2.1 删除文件12rm file.txt # 删除文件，后面可以跟多个文件，以空格隔开rm -rf 文件夹 # 递归删除整个目录，并且不询问用户[强制删除] 2.2 新建文件123456vi test.txt #若果当前目录木有test.txt文件，则会自动新建touch test.txt # 新建test.txt文件``` ### 2.3 更改文件属组``` bashchown users:jessie file1.txt #修改文件file1.txt 为jessie组的users用户所有 2.3 更改文件属性[读\\写\\执行]Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。12345678910111213141516171819chmod [-cfvR] [--help] [--version] mode file...权限设定参数：[ugoa...][[+-=][rwxX]...][,...]u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。chmod a+r file1.txt # 将文件 file1.txt 设为所有人皆可读取 chmod u+x ex1.py # 将 ex1.py 设定为只有该文件拥有者可以执行chmod -R a+r * # 将目前目录下的所有文件与子目录皆设为任何人可读取，[其中R代表递归操作]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`chmod 777 file其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。r=4，w=2，x=1若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=5。 2.4 解压、压缩文件123zip 目录 # 将传入目录里的文件压缩为zip文件,并放置在上一级目录unzip file.zip # 将file.zip解压并放在当前目录unzip file.zip -d cn #将file.zip解压并存放在cn目录，没有此目录会自动新建 2.5 服务器间拷贝文件 Linux scp命令用于Linux之间复制文件和目录。 scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。 此命令根据执行机是不是目标机器，可对应实现“推文件”和“拉取文件”操作。 语法1scp [可选参数] file_source file_target 重要参数123-p：保留原文件的修改时间，访问时间和访问权限。-q： 不显示传输进度条。-r： 递归复制整个目录。 实例：1scp /home/space/music/1.mp3 www.xxx.com:/home/root/others/music/001.mp3 命令格式123scp -r local_folder remote_username@remote_ip:remote_folder 或者 scp -r local_folder remote_ip:remote_folder 实例：1scp -r /home/space/music/ root@www.xxx.com:/home/root/others/ 3.其他3.1 定时任务Linux crontab是用来定期执行程序的命令。 当安装完成操作系统之后，默认便会启动此任务调度命令。 crond命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。 而linux任务调度的工作主要分为以下两类： 系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存 个人执行的工作：某个用户定期要做的工作，例如每隔10分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置 语法1crontab [ -u user ] &#123; -l | -r | -e &#125; 说明： crontab 是用来让使用者在固定时间或固定间隔执行程序之用，换句话说，也就是类似使用者的时程表。 -u user 是指设定指定 user 的时程表，这个前提是你必须要有其权限(比如说是 root)才能够指定他人的时程表。如果不使用 -u user 的话，就是表示设定自己的时程表。 参数说明： -e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe) -r : 删除目前的时程表 -l : 列出目前的时程表 时程表的格式如下：1f1 f2 f3 f4 f5 program 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。 当 f1 为 时表示每分钟都要执行 program，f2 为 时表示每小时都要执行程序，其馀类推 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推 当 f1 为 /n 时表示每 n 分钟个时间间隔执行一次，f2 为 /n 表示每 n 小时个时间间隔执行一次，其馀类推 当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推 使用者也可以将所有的设定先存放在文件中，用 crontab file 的方式来设定时程表。123456789101112130 */2 * * * /sbin/service httpd restart #意思是每两个小时重启一次apache 50 7 * * * /sbin/service sshd start #意思是每天7：50开启ssh服务 50 22 * * * /sbin/service sshd stop #意思是每天22：50关闭ssh服务 0 0 1,15 * * fsck /home #每月1号和15号检查/home 磁盘 1 * * * * /home/bruce/backup #每小时的第一分执行 /home/bruce/backup这个文件 00 03 * * 1-5 find /home \"*.xxx\" -mtime +4 -exec rm &#123;&#125; \\; #每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。30 6 */10 * * ls #意思是每月的1、11、21、31日是的6：30执行一次ls命令 【未完待续】","categories":[{"name":"linux&&shell","slug":"linux-shell","permalink":"http://yoursite.com/categories/linux-shell/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"后台","slug":"后台","permalink":"http://yoursite.com/tags/后台/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-06T15:32:15.941Z","updated":"2017-10-28T00:39:58.000Z","comments":true,"path":"2018/08/06/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}